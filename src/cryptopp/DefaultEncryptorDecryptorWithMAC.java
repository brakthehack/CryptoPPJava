/**
 * Boost Software License - Version 1.0 - August 17th, 2003
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
   
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
   
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
package cryptopp;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.nio.charset.Charset;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.Security;
import java.security.SignatureException;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Hex;
import org.apache.commons.io.IOUtils;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

/**
 * A port of the DefaultEncryptor/Decryptor with MAC functions from the CryptoPP c++ library v5.6.2
 * The default algorithm uses DES-ede2 algorithm with HMAC-SHA1
 * Requires a @see <a href="https://www.bouncycastle.org/latest_releases.html">BouncyCastle provider</a>
 * @author Brian Rak
 * @since 2014-21-11
 *
 */
public class DefaultEncryptorDecryptorWithMAC {

	// Application specific variables used in CryptoPP DefaultEncryptor and DefaultDecryptor
	// it is not recommended that you change these unless you know what you are doing!
	private static final Charset CHARSET = Charset.forName("utf-8");
	private static final String CIPHER_PADDING = "DESede/CBC/PKCS7Padding";
	private static final String HMAC_SHA1_ALGORITHM = "HmacSHA1";
	private static final String SHA1_ALGORITHM = "sha1";
	
	private static final int MASH_ITERATIONS = 200;
	private static final int KEYLENGTH = 16;
	private static final int BLOCKSIZE = 8;
	private static final int DIGESTSIZE = 20;
	private static final int SALTLENGTH = 8;
	private static final int HMACLEN = 16;

	static {
		Security.addProvider(new BouncyCastleProvider());
	}
	
	/**
	 * Encrypts some plain text with a given password
	 * @param text the plaintext to be encrypted
	 * @param password the password used to encrypt the file
	 * @return the ciphertext
	 * @throws Exception if the data could not be encrypted
	 */
	public byte[] encrypt(final byte[] text, final String password)
			throws Exception {
		
		final byte[] passwordBytes = password.getBytes(CHARSET);
		final byte[] salt = generateSalt(passwordBytes, SALTLENGTH);
		
		// the keycheck is used to check if a given key is valid or not using a check against some expected bytes
		byte[] keycheck = Arrays.copyOf(generateKeyCheck(passwordBytes, salt), BLOCKSIZE);
		final KeyIV keyIV = generateKeyIV(passwordBytes, salt, MASH_ITERATIONS);
		
		final Cipher cipher = Cipher.getInstance(CIPHER_PADDING, "BC");
		cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(keyIV.key, "DESede"),
				new IvParameterSpec(keyIV.IV));

		byte[] hmac = calculateHmacSHA1(text, passwordBytes, HMACLEN);
		//perform the encryption
		// final result should look like: SALT | ENCRYPTED<KEYCHECK | TEXT | HMAC>
		byte[] ciphertext = cipher.doFinal(concat(concat(keycheck, text), hmac));
		return concat(salt,ciphertext);
	}

	/**
	 * Decrypts the ciphertext with a given password
	 * @param ciphertext the encrypted text to be decrypted
	 * @param password the password used to decrypt the file
	 * @return the original message
	 * @throws Exception if the key or mac could not be validated, or any corruption of the blocks or padding
	 */
	public byte[] decrypt(final byte[] ciphertext, final String password)
			throws Exception {
		
		final byte[] passwordBytes = password.getBytes(CHARSET);
		final byte[] salt = Arrays.copyOf(ciphertext, SALTLENGTH);
		
		final KeyIV keyIV = generateKeyIV(passwordBytes, salt, MASH_ITERATIONS);
		
		final Cipher cipher = Cipher.getInstance(CIPHER_PADDING, "BC");
		cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(keyIV.key, "DESede"), 
				new IvParameterSpec(keyIV.IV));
		
		//perform the decryption
		byte[] cipherWithoutSalt = Arrays.copyOfRange(ciphertext, SALTLENGTH, ciphertext.length);
		byte[] plaintext = cipher.doFinal(cipherWithoutSalt);
		
		// remove the keycheck and verify the key
		
		byte[] keycheck = Arrays.copyOfRange(plaintext, 0, BLOCKSIZE);
		if (!verifyKey(keycheck, salt, passwordBytes)) {
			throw new Exception("Could not decrypt data: Invalid key");
		}
		
		byte[] originalMessage = Arrays.copyOfRange(plaintext, BLOCKSIZE, plaintext.length - DIGESTSIZE);
		
		// remove the HMAC and verify it
		byte[] hmac = Arrays.copyOfRange(plaintext, plaintext.length - DIGESTSIZE, plaintext.length);
		if (!verifyHMAC(hmac, originalMessage, salt, passwordBytes)) {
			throw new Exception("Message or MAC is corrupted: Invalid HMAC");
		}
		
		// return only the original message, removing the HMAC, and keycheck (salt already removed)
		return originalMessage;
	}
	
	/**
	 * Verifies if the key is valid doing a check against a message we expect
	 * @param toCheck the keycheck contained in the ciphertext
	 * @param salt the salt
	 * @param password the password
	 * @return true if the key to decrypt this ciphertext is valid
	 * @throws NoSuchAlgorithmException 
	 */
	private boolean verifyKey(byte[] toCheck, byte[] salt, byte[] password) throws NoSuchAlgorithmException {
		return Arrays.equals(toCheck, Arrays.copyOf(generateKeyCheck(password, salt), BLOCKSIZE));
	}
	
	/**
	 * Verifies in HMAC is valid
	 * @param toVerify the hmac contained in the received message
	 * @param salt the salt
	 * @param password the password used to encrypt and decrypt
	 * @return true if the hmac could be verified
	 * @throws SignatureException 
	 */
	private boolean verifyHMAC(byte[] toVerify, byte[] plaintext, byte[] salt, byte[] password) throws SignatureException {
		return Arrays.equals(toVerify, calculateHmacSHA1(plaintext, password, HMACLEN));
	}
	
	/**
	 * Concatenates two byte arrays and returns the concatenated result
	 * @param a the prepended array
	 * @param b the appended array
	 * @return the concatenated array
	 */
	private static byte[] concat(byte[] a, byte[] b) {
		byte[] concat = new byte[a.length + b.length];
		System.arraycopy(a, 0, concat, 0, a.length);
		System.arraycopy(b, 0, concat, a.length, b.length);
		return concat;
	}
	
	/**
	 * Computes RFC 2104-compliant HMAC signature.
	 * @param data The data to be signed.
	 * @param key The signing key
	 * @return The Base64-encoded RFC 2104-compliant HMAC signature.
	 * @author @see <a href="http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/AuthJavaSampleHMACSignature.html">Amazon Web Services</a>
	 * @throws java.security.SignatureException when signature generation fails
	 */
	private static byte[] calculateHmacSHA1(final byte[] data, final byte[] password, int newKeyLen)
			throws SignatureException {
		try {
			byte[] key = mash(password, newKeyLen, 1);
			// get an hmac_sha1 key from the raw key bytes
			SecretKeySpec signingKey = new SecretKeySpec(key, HMAC_SHA1_ALGORITHM);

			// get an hmac_sha1 Mac instance and initialize with the signing key
			Mac mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);
			mac.init(signingKey);

			// compute the hmac on input data bytes
			return mac.doFinal(data);
		} catch (Exception e) {
			throw new SignatureException("Failed to generate HMAC : " + e.getMessage());
		}
	}
	
	/**
	 * A modification of Wei Dai's salt generation algorithm using Java's SecureRandom instead of time and clock
	 * @param passwordBytes the password used to generate the salt
	 * @param saltLength the expected salt length
	 * @return the new salt of a given salt length
	 * @throws NoSuchAlgorithmException
	 */
	private static byte[] generateSalt(final byte[] passwordBytes, int saltLength) throws NoSuchAlgorithmException {
		byte[] salt = new byte[SALTLENGTH];
		SecureRandom rng = SecureRandom.getInstance("SHA1PRNG");
		rng.setSeed(passwordBytes);
		rng.nextBytes(salt);
		return salt;
	}
	
	/**
	 * Container to hold a key and IV 
	 * for the {@link #generateKeyIV(byte[], byte[], int) keyIV generation } algorithm
	 * @author Brian Rak
	 *
	 */
	private static class KeyIV {
		byte[] key = new byte[KEYLENGTH];
		byte[] IV = new byte[BLOCKSIZE];
	}
	
	/* 
	 * THE FUNCTIONS BELOW HAVE BEEN PORTED FROM CRYPTO++ LIBRARY
	 * ALL CREDIT GOES TO WEI DAI 
	 */ 
	
	/**
	 * Taken from CryptoPP ...
	 * The purpose of this function Mash() is to take an arbitrary length input
	 * string and *deterministically* produce an arbitrary length output string such
	 * that (1) it looks random, (2) no information about the input is
	 * deducible from it, and (3) it contains as much entropy as it can hold, or
	 * the amount of entropy in the input string, whichever is smaller.
	 * @param in the bytes to mash
	 * @param out the size of the output
	 * @param iters the number of iterations
	 * @return the new bytes according to <code>out</code>
	 * @throws Exception 
	 */
	private static final byte[] mash(final byte[] in, int out, int iters) throws Exception {
		if (MathUtils.checkBytePrecision(out) < 0) {
			throw new IllegalArgumentException("Mash output length too large");
		}
		int bufSize = MathUtils.roundUpToMultipleOf(out, DIGESTSIZE);
		byte[] b = new byte[2];
		byte[] buf = new byte[bufSize];
		byte[] outBuf = new byte[bufSize];
		MessageDigest hash = MessageDigest.getInstance(SHA1_ALGORITHM);
		
		for (int i = 0; i < out; i += DIGESTSIZE) {
			b[0] = (byte) (i >>> 8);
			b[1] = (byte) i;
			hash.update(b);
			hash.update(in);
			byte[] digest = hash.digest();
			System.arraycopy(digest, 0, outBuf, i, digest.length);
		}
		
		while (iters-- > 1) {
			System.arraycopy(outBuf, 0, buf, 0, bufSize);
			for (int i = 0; i < bufSize; i += DIGESTSIZE) {
				b[0] = (byte) (i >>> 8);
				b[1] = (byte) i;
				hash.update(b);
				hash.update(buf);
				byte[] digest = hash.digest();
				System.arraycopy(digest, 0, outBuf, i, digest.length);
			}
		}
		return Arrays.copyOfRange(outBuf, 0, out);
	}
	
	/**
	 * Algorithm to generate a key and initialization vector
	 * @param password the password used to generate
	 * @param salt the salt
	 * @param iters the number of iterations to mash (creating entropy)
	 * @return the key and initialization vector
	 * @throws Exception
	 */
	private KeyIV generateKeyIV(final byte[] password, final byte[] salt, int iters) throws Exception {
		int size = password.length + salt.length;
		byte[] temp = new byte[size];
		KeyIV keyIV = new KeyIV();
		System.arraycopy(password, 0, temp, 0, password.length);
		System.arraycopy(salt, 0, temp, password.length, salt.length);
		byte[] mashed = mash(temp, KEYLENGTH + BLOCKSIZE, iters);
		System.arraycopy(mashed, 0, keyIV.key, 0, KEYLENGTH);
		System.arraycopy(mashed, KEYLENGTH, keyIV.IV, 0, BLOCKSIZE);
		return keyIV;
	}
	
	/**
	 * Generates the keycheck using Wei Dai's keycheck algorithm
	 * The keycheck is used to decrypt a part of the message we expect to see.
	 * If we cannot decrypt this message and and verify the two buffers, the key is not valid
	 * and cannot decrypt the user's message.
	 * @param passphrase the password to encrypt and decrypt the plaintext
	 * @param salt the salt
	 * @return the resulting keycheck
	 * @throws NoSuchAlgorithmException
	 */
	private static byte[] generateKeyCheck(final byte[] passphrase, final byte[] salt) throws NoSuchAlgorithmException {
		MessageDigest hash = MessageDigest.getInstance(SHA1_ALGORITHM);
		hash.update(passphrase);
		hash.update(salt);
		return hash.digest();
	}
	
	/**TEST AND MAIN FUNCTIONS BEGIN BELOW **/
	
	public static void main(String[] args) throws Exception {
		if (args.length != 2) {
			System.out.println("Usage: java DefaultEncryptorWithMAC text password");
			System.exit(1);
		}
		DefaultEncryptorDecryptorWithMAC encoderDecoder;
		if (args.length == 2) {
			encoderDecoder = new DefaultEncryptorDecryptorWithMAC();
			begin(args[0], args[1], encoderDecoder);
		} else {
			System.out.println("Invalid arguments");
		}
	}
	
	/**
	 * Testing method only
	 * @param text
	 * @throws Exception
	 */
	public static void begin(final String text, final String password, DefaultEncryptorDecryptorWithMAC encoderDecoder) throws Exception {

		System.out.println("Original String: ");
		System.out.println("\t" + text);

		//Use predefined key
		System.out.println("Key: \t" + password);

		byte[] encryptedText = encoderDecoder.encrypt(text.getBytes(), password);
		FileOutputStream fos = new FileOutputStream(new File("encrypted.bin"));
		fos.write(encryptedText);
		fos.flush();
		fos.close();
		System.out.println(encryptedText.length);
		System.out.println("Encrypted Text Hex Encoded: \n\t" + 
				new String(Hex.encodeHex(encryptedText)) + "\n" );

		ByteArrayOutputStream out = new ByteArrayOutputStream();
		FileInputStream in = new FileInputStream("encrypted.bin");
		IOUtils.copy(in, out);
		byte[] b = out.toByteArray();
		in.close();
		out.close();
		byte[] decryptedText = encoderDecoder.decrypt(b, password);

		System.out.println("Original Text Decrypted: ");
		System.out.println("\t" + new String(decryptedText));
	
	}
}